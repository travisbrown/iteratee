package io.iteratee

import cats.Eval
import io.iteratee.testing.{ EnumerateeSuite, IterateeSuite, StackSafeEnumeratorSuite }
import io.iteratee.tests.EvalSuite

class EvalEnumerateeTests extends EnumerateeSuite[Eval] with EvalSuite

class EvalEnumeratorTests extends StackSafeEnumeratorSuite[Eval] with EvalSuite {
  "perform" should "perform an action" in forAll { (eav: EnumeratorAndValues[Int]) =>
    var counter = 0
    val action = perform[Int](Eval.always(counter += 1))
    val enumerator = action.append(eav.enumerator).append(action)

    assert(counter === 0)
    assert(enumerator.toVector === Eval.now(eav.values))
    assert(counter === 2)
  }

  "generateM" should "enumerate values generated by an effectful function" in forAll { (n: Short) =>
    val count = math.abs(n.toInt)
    var counter = 0
    val enumerator = generateM(
      Eval.always(
        if (counter > count) None else Some {
          val result = counter
          counter += 1
          result
        }
      )
    )

    assert(enumerator.toVector === Eval.now((0 to count).toVector))
    assert(counter == count + 1)
  }

  "StackUnsafe.generateM" should "enumerate values generated by an effectful function" in forAll { (n: Short) =>
    val count = math.abs(n.toInt)
    var counter = 0
    val enumerator = Enumerator.StackUnsafe.generateM(
      Eval.always(
        if (counter > count) None else Some {
          val result = counter
          counter += 1
          result
        }
      )
    )

    assert(enumerator.toVector === Eval.now((0 to count).toVector))
    assert(counter == count + 1)
  }
}

class EvalIterateeTests extends IterateeSuite[Eval] with EvalSuite
